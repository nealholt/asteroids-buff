import pygame

#It's necessary to do the next part before anyone imports displayUtilities now that we are pre-loading images.
pygame.init()
import globalvars
#set up the display:
globalvars.screen = pygame.display.set_mode((globalvars.WIDTH, globalvars.HEIGHT))

import random as rd
import sys
sys.path.append('code')
import player as playerObj
import colors
import testFunctions as test
import menus
from geometry import distance, angleFromPosition, translate, rotateAngle
from displayUtilities import writeTextToScreen
import datetime #Use for testing efficiency
import nodeManager
import factions

#instantiate sprite groups
globalvars.tangibles = pygame.sprite.Group()
globalvars.intangibles_bottom = pygame.sprite.Group()
globalvars.intangibles_top = pygame.sprite.Group()
#This last group will contain any sprites that will tickle whiskers
globalvars.whiskerables = pygame.sprite.Group()

#Player must be created before scenario is called.
globalvars.player = playerObj.Player('ship')

globalvars.galaxy = nodeManager.NodeManager()
globalvars.galaxy.generateGalaxy(seed=0, nodecount=globalvars.NUMBEROFNODES, minimumNodeDist=4)

globalvars.factions = factions.FactionManager()

#More efficient animations:
dirty_rects = []
useDirty = True #Whether to flip or use dirty rectangles

def redrawWholeBackground():
	if globalvars.BGIMAGE is None:
		globalvars.screen.fill(globalvars.BGCOLOR)
	else:
		globalvars.screen.blit(globalvars.BGIMAGE, (0,0))


def addToDirtyRects(physObject, offset, cover=True):
	'''Draws over the physical object if it is on the screen.
	Adds physObject to dirty rects only if physObject is on screen.
	Returns whether or not physObject is on screen.'''
	isOn = physObject.isOnScreen(offset)
	if isOn:
		pos = physObject.rect.topleft
		#Whether to offset this object's location based on the camera.
		#Text does not useOffset because we want to only position it relative to 0,0
		if physObject.useOffset:
			pos = pos[0]-offset[0], pos[1]-offset[1]
		my_rect = (pos[0], pos[1], physObject.rect.width, physObject.rect.height)
		# - Blit a piece of the background over the sprite's current location, erasing it.
		if cover:
			if globalvars.BGIMAGE is None:
				globalvars.screen.fill(globalvars.BGCOLOR, rect=my_rect)
			else:
				globalvars.screen.blit(globalvars.BGIMAGE, pos, area=my_rect)
		# - Append the sprite's current location rectangle to a list called dirty_rects.
		dirty_rects.append(my_rect)
	return isOn


def run(countdown=-1):
	'''Runs the game.
	Countdown is used for profiling.'''
	global dirty_rects

	fps = globalvars.FPS
	offsetx = 0
	offsety = 0
	offset = offsetx, offsety

	#key polling:
	#Use this to keep track of which keys are up and which 
	#are down at any given point in time.
	keys = []
	for _i in range (322):
		keys.append(False)
	#mouse is [pos, button1, button2, button3,..., button6].
	#new Apple mice think they have 6 buttons.
	#Use this to keep track of which mouse buttons are up and which 
	#are down at any given point in time.
	#Also the tuple, mouse[0], is the current location of the mouse.
	mouse = [(0, 0), 0, 0, 0, 0, 0, 0]

	#pygame setup:
	clock = pygame.time.Clock()

	pause = False

	running = True

	#The in-round loop (while player is alive):
	while running:
		#Use this for more accurate profiling:
		if countdown != -1:
			countdown -= 1
			if countdown < 0:
				exit()

		#Draw everything on the screen. Do so either using dirty rects or just by
		#redrawing the whole screen. Dirty rects are usually more efficient.
		if useDirty:
			pygame.display.update(dirty_rects)
			dirty_rects = []
		else:
			pygame.display.flip()

		#Used for calculating actual frames per second in
		#order to determine when we are dropping frames
		#so that efficiency improvements can be made.
		start_time = datetime.datetime.now()
		#frame maintainance:
		#aim for globalvars.FPS frames per second.
		clock.tick(globalvars.FPS) 
		fps = max(1, int(clock.get_fps()))

		if useDirty:
			#Put on screen rects in dirty rects.
			for x in globalvars.intangibles_bottom: addToDirtyRects(x, offset)
			for x in globalvars.tangibles: addToDirtyRects(x, offset)
			for x in globalvars.intangibles_top: addToDirtyRects(x, offset)

		#Skip the rest of this loop until the game is unpaused.
		if pause:
			#Write paused in the middle of the screen
			writeTextToScreen(string='PAUSED', fontSize=128,\
				pos=(globalvars.WIDTH/3, globalvars.HEIGHT/2))
			#Check for another s key press to unpause the game.
			for event in pygame.event.get():
				if event.type == pygame.KEYDOWN and event.key == 112: #p key
					pause = not pause
			#Skip the rest of this loop until the game is unpaused.
			continue

		#Display the panel
		if not globalvars.panel is None:
			globalvars.panel.draw()
			pygame.display.flip()
			#Check for another key press to remove the panel.
			for event in pygame.event.get():
				#Check for event m key, n key, or escape key being 
				#pressed to remove the menu.
				if event.type == pygame.KEYDOWN:
					globalvars.panel = None
					redrawWholeBackground()
					pygame.display.flip()
					break
				#Panel event handeling can make the panel itself None so we have 
				#to check if the panel has become None for every event. If the
				#panel has become None we break and ignore further input events.
				elif globalvars.panel is None:
					redrawWholeBackground()
					pygame.display.flip()
					break
				#Pass all other events to the panel
				else:
					globalvars.panel.handleEvent(event)
			#Skip all the rest while displaying the menu.
			#This effectively pauses the game.
			continue

		#event polling:
		#See what buttons may or may not have been pushed.
		for event in pygame.event.get():
			if event.type == pygame.QUIT:
				running = False
			elif event.type == pygame.MOUSEBUTTONDOWN:
				mouse[event.button] = 1
				mouse[0] = event.pos
				#Also causes shooting
				globalvars.player.shoot(force_shot=True)
			elif event.type == pygame.MOUSEBUTTONUP:
				mouse[event.button] = 0
			#elif event.type == pygame.MOUSEMOTION:
			#	mouse[0] = event.pos
			elif event.type == pygame.KEYDOWN:
				keys[event.key % 322] = 1
				print "TODO TESTING: key press "+str(event.key)

				#Respond to key taps.
				#Keys that we want to respond to holding them down
				#will be dealt with below.
				if event.key == 273 or event.key == 119: #Pressed up arrow or w key
					#increase speed by a fraction of max up to max.
					globalvars.player.targetSpeed = min(\
						globalvars.player.maxSpeed,\
						globalvars.player.targetSpeed +\
						globalvars.player.maxSpeed*\
						globalvars.player.speedIncrements)
				elif event.key == 274 or event.key == 115: #Pressed down arrow or s key
					#decrease speed by a fraction of 
					#max down to zero.
					globalvars.player.targetSpeed = max(0,\
						globalvars.player.targetSpeed -\
						globalvars.player.maxSpeed*\
						globalvars.player.speedIncrements)
				elif event.key == 27: #escape key or red button
					running = False
				elif event.key == 109: #m key
					#If player is dead, access the restart panel, not the testing panel.
					if globalvars.player.isDead():
						menus.setRestartPanel()
					else:
						menus.setTestingPanel()
					continue
				elif event.key == 98: #b key
					globalvars.player.parkingBrake()
				elif event.key == 113: #q key
					#Obliterate destination.
					#Change to free flight.
					globalvars.player.killDestination()
				elif event.key == 112: #p key
					pause = not pause; continue
				elif event.key == 116: #t key
					#shoot a bunch of hit box testers 
					#in towards the player
					print 'Width: '+\
					    str(globalvars.player.image.get_width())+\
					' vs '+str(globalvars.player.rect.width)
					print 'Height: '+\
					    str(globalvars.player.image.get_height())+\
					' vs '+str(globalvars.player.rect.height)
					test.hitBoxTest(globalvars.player.rect.center)
				elif event.key == 121: #y key
					#Profile lots of methods, but not game.run()
					profileEverything(offset)
				elif event.key == 117: #u key
					#Profile game.run()
					import cProfile
					print 'Profiling game.run(countdown=1800). '+\
						'Press escape to quit early. '+\
						'Profiling will stop automatically after 30 seconds.'
					#Run for 1800 frames (or 30 seconds assuming 60 frames per second.
					cProfile.runctx('run(countdown=1800)', globals(),None,
						'profiling/game.run.profile')
					exit()
				elif event.key == 47:
					#forward slash (question mark
					#without shift) key.
					#Useful for querying one time info.
					print 'Print player destination: '+\
					str(globalvars.player.destx)+','+\
					str(globalvars.player.desty)
				elif event.key == 104 or event.key == 304: #"h key" lower or upper case.
					#Display help menu.
					globalvars.panel = menus.getHelpPanel()

				if event.key == 120: #Pressed x key
					globalvars.player.shoot(force_shot=True,weapon=globalvars.player.missile)
				if event.key == 122: #Pressed z key
					globalvars.player.shoot(force_shot=True, weapon=globalvars.player.mine)


			elif event.type == pygame.KEYUP:
				#Keep track of which keys are no longer
				#being pushed.
				keys[event.key % 322] = 0

		##This will make the player move towards the mouse 
		##without any clicking involved.
		##Set player destination to current mouse coordinates.
		if mouse[1]:
			x,y = pygame.mouse.get_pos()
			x += offsetx
			y += offsety
			globalvars.player.setDestination((x,y))

		#Respond to key holds.
		#Keys that we want to respond to tapping them
		#will be dealt with above.
		if keys[276] or keys[97]: #Pressed left arrow or a key
			globalvars.player.turnCounterClockwise()
		elif keys[275] or keys[100]: #Pressed right arrow or d key
			globalvars.player.turnClockwise()
		#This is not part of the above else if.
		#You can shoot and turn at the same time.
		if keys[32] or keys[99]: #Pressed space bar or c key
			#Force shot tells this to shoot even if a target 
			#is not obviously in view. NPC's will not take such wild shots.
			globalvars.player.shoot(force_shot=True)



		#Check all collisions
		collisionHandling()

		#If arena is non-zero, then make sure player and all 
		#whiskerables are within it
		if globalvars.arena > 0:
			#The inner concentric ring bounces the player back 
			#towards center (don't actually bounce, just change 
			#angle directly towards center. The outer 
			#concentric ring, defined by distance from center 
			#plus object radius will bounce asteroids in a 
			#semi random direction towards the center-ish area.

			#Make sure player is within arena.
			#If not, change player's heading to be towards 0,0
			if distance(globalvars.player.rect.center, (0.,0.)) > globalvars.arena:
				globalvars.player.theta = angleFromPosition(\
					globalvars.player.rect.center, (0.,0.))
				globalvars.player.updateImageAngle()
			#Check each whiskerable and if it is more than 
			#arena + diameter from center, then change its 
			#angle to point somewhere within the arena too.
			for w in globalvars.whiskerables:
				if distance(w.rect.center, (0.,0.)) > \
				globalvars.arena + w.collisionradius:
					#Whiskerables reflect randomly
					#off arena boundaries towards a
					#point somewhere within 3/4 the
					#center of the arena.
					limit = 3*globalvars.arena/4
					x = rd.randint(-limit, limit)
					y = rd.randint(-limit, limit)
					if not w.direction is None:
						#Asteroids distinguish between their orientation,
						#theta, and direction of movement, direction.
						#Thus we want direction changed, not theta.
						w.direction = angleFromPosition(\
							w.rect.center, (x,y))
					else:
						w.theta = angleFromPosition(w.rect.center, (x,y))

		#Update player's lead target indicator so enemies shoot at a spot just ahead of the player.
		globalvars.player_target_lead = globalvars.player.getLeadIndicator()

		#update all sprites:

		#First tell the ships what is closest to them
		#so that they can avoid collisions
		setClosestSprites()

		#Update all the sprites
		globalvars.intangibles_bottom.update()
		globalvars.tangibles.update()
		globalvars.intangibles_top.update()

		#Get the offset based on the player location.
		offsetx = globalvars.player.rect.centerx - globalvars.CENTERX
		offsety = globalvars.player.rect.centery - globalvars.CENTERY
		offset = offsetx, offsety

		if useDirty:
			#Put on screen rects in dirty rects
			for x in globalvars.intangibles_bottom:
				if addToDirtyRects(x, offset, cover=False):
					x.draw(offset)
			for x in globalvars.tangibles:
				if addToDirtyRects(x, offset, cover=False):
					x.draw(offset)
			for x in globalvars.intangibles_top:
				if addToDirtyRects(x, offset, cover=False):
					x.draw(offset)
		else:
			#Draw the background over the screen.
	                redrawWholeBackground()
	                #Draw all the things that are on the screen
	                drawThoseOnScreen(globalvars.intangibles_bottom, offset)
	                drawThoseOnScreen(globalvars.tangibles, offset)
	                drawThoseOnScreen(globalvars.intangibles_top, offset)

		#Draw player last so the background isn't drawn overtop of the player.
		globalvars.player.playerUpdate()
		if not globalvars.player.isDead() and globalvars.player.fuel > 0:
			if useDirty:
				addToDirtyRects(globalvars.player, offset, cover=False)
			else:
				globalvars.player.drawAt((globalvars.CENTERX, globalvars.CENTERY))
		else:
			#Make player death kick the player back to a menu where player 
			#can choose to restart. Display a death screen then. Reset the 
			#scenario and everything else.
			#Countdown before kicking player back to menu
			globalvars.deathcountdown -= 1
			if globalvars.deathcountdown < 0:
				menus.setRestartPanel()

		#Calculate how long we took in the above loop to estimate the number of frames per second
		#Alert user if fraps drops below half the desired threshold.
		time_lapse = datetime.datetime.now() - start_time
		if float(time_lapse.microseconds)/1000000. > (2.0/globalvars.FPS):
			print 'Warning: frames dropping.'
			print 'Goal frames per second is '+str(globalvars.FPS)+'. Current is '+str(1./(float(time_lapse.microseconds)/1000000.))[:2] #Cut off decimal because I don't care.
			print 'Sizes of Sprite Groups follows:'
			print 'Tangibles: '+str(len(globalvars.tangibles))
			print 'Intangibles_bottom: '+str(len(globalvars.intangibles_bottom))
			print 'Intangibles_top: '+str(len(globalvars.intangibles_top))
			print 'Whiskerables: '+str(len(globalvars.whiskerables))
			print
	#end round loop (until gameover)
#end game loop



def drawThoseOnScreen(sprite_list, offset):
        '''Takes a list of pygame sprites and the top left coordinates of the screen 
        and draws only those sprites that are visible on screen.
        I tested (see "y key" above) with and without checking whether or not each
        sprite is on the screen before drawing it and I found checking to be more
        efficient in multiple scenarios. The gain is less than I expected and
        a major inefficiency in python seems to be function calls, making me wonder 
        how important it is to wrap this into the run method, but I'm going to avoid 
        that for now.'''
        #draw_count = 0 #TESTING
        left, top = offset
        for sp in sprite_list:
                #If the sprite is on the screen, then draw it.
                if sp.isOnScreen(offset):
			sp.draw(offset)
                        #draw_count += 1 #TESTING
        #print str(draw_count)+' objects on screen.' #TESTING


def setClosestSprites():
	'''Pre:
	Post: For all ships in the whiskerables sprite list, the closest sprite 
	and the distance to that sprite is set. This is used for helping NPC 
	ships avoid collisions.'''
	#Get all the whiskerable sprites in an array
	sprite_list = globalvars.whiskerables.sprites()
	#TODO I'd like to make use of sorting like I do for collision checking with this, but recently it was gumming up the works, so I'm simplifying it for now.
	#Sort them by their top point as is done when checking for collisions.
	#sprite_list = sorted(sprite_list, \
	#	key=lambda c: c.rect.topleft[1]+c.rect.height,\
	#	reverse=True)
	#For each sprite...
	for i in xrange(len(sprite_list)):
		#Get the next sprite to deal with.
		A = sprite_list[i]
		#only ships can avoid objects.
		if A.is_a != globalvars.SHIP: #TODO this could be more efficient by keeping another group that is just ships. Of course there is a cost there. It might be worth profiling at some point to see if this is better or another group that is just non-player ships is better.
			continue
		#Reset closest sprite and the distance to that sprite. Sprites 
		#further than this distance will be ignored.
		closest_sprite = None
		least_dist = globalvars.MINSAFEDIST
		#search for too close sprites
		for j in xrange(len(sprite_list)):
			if j != i:
				B = sprite_list[j]
				dist = distance(A.rect.center, B.rect.center) - B.collisionradius - A.collisionradius
				if dist < least_dist:
					least_dist = dist
					closest_sprite = B
		#Set sprite A's closest sprite and the distance to that sprite.
		A.setClosest(closest_sprite, least_dist)


def collisionHandling():
	'''The following function comes from pseudo code from
	 axisAlignedRectangleCollision.txt that has been modified.'''
	#Get a list of all the sprites
	sprite_list = globalvars.tangibles.sprites()
	#sort the list in descending order based on each 
	#sprite's y coordinate (aka top) plus height.
	#Remember that larger y coordinates indicate further down
	#on the screen.
	#Reverse tells sorted to be descending.
	#rect.topleft[1] gets the y coordinate, top.
	sprite_list = sorted(sprite_list, \
		key=lambda c: c.rect.bottom,\
		reverse=True)
	#TODO I'm a bit concerned that I just sorted by bottom when now some things can have custom hit boxes (mainly the capital ship).
	#iterate over the sprite list
	for i in xrange(len(sprite_list)):
		A = sprite_list[i]
		for j in xrange(i+1, len(sprite_list)):
			B = sprite_list[j]
			#if A's least y coord (A's top) is > B's
			#largest y coord (B's bottom)
			#then they don't overlap and none of the following
			#sprites overlap A either becuase the list is sorted
			#by bottom y coordinates.
			#We therefore skip the rest of the sprites in the list.
			if A.rect.top > B.rect.bottom:
				break
			else:
				#Otherwise, we need to see if they overlap
				#in the x direction.
				#if A's greatest x coord is < B's least x coord
				#or B's greatest x coord is < A's least x coord
				#then they don't overlap, but one of the following 
				#sprites might still overlap so we move to the
				#next sprite in the list.
				if A.inCollision(B):
					#they overlap. They should handle 
					#collisions with each other.
					A_died = A.handleCollisionWith(B)
					B.handleCollisionWith(A)
					#If A has died, then don't worry about A
					#colliding with anything else.
					if A_died: break


def profileEverything(offset):
	import cProfile
	cProfile.runctx('for _ in range(10000): collisionHandling()', globals(),locals(), 'profiling/collisionHandling.profile')
	cProfile.runctx('for _ in range(10000): setClosestSprites()', globals(),locals(), 'profiling/setClosestSprites.profile')
	cProfile.runctx('for _ in range(10000): globalvars.tangibles.update()', globals(),locals(), 'profiling/updateTangibles.profile')

	#Profile some of the scenario functions.
	menus.scenarios.profile()

